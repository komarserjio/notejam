# get_notes user (Maybe pad_id)   -> (Pad, [Note])
# get_note  user id               -> Note
# pop_note  user id               -> Note
# add_note  user    name text pad -> Note
# set_note  user id name text pad
# get_pads  user                  -> [Pad]
# set_pad   user id name
# check_user  email (Maybe password) -> User
# create_user email        password  -> User
# update_user user         password  -> User
# set_user_password email password

import '/time'
import '/itertools'
import '/collections'
import '/xml/sax/saxutils/escape'

import '/sqlalchemy/create_engine'
import '/sqlalchemy/Column'
import '/sqlalchemy/String'
import '/sqlalchemy/Integer'
import '/sqlalchemy/ForeignKey'
import '/sqlalchemy/ext/declarative/declarative_base'
import '/sqlalchemy/orm/sessionmaker'
import '/sqlalchemy/orm/relationship'
import '/sqlalchemy/orm/backref'

import '/hoep'
import '/pygments/lexers'     qualified
import '/pygments/formatters' qualified

import 'config'


_MdRenderer = subclass hoep.Hoep where block_code = code lang ~> except
  e => pygments.highlight code
    pygments.lexers.get_lexer_by_name lang
    pygments.formatters.HtmlFormatter!
  e :: Exception => '<pre>{}</pre>'.format $ escape code


_md_renderer = _MdRenderer
  hoep.EXT_FENCED_CODE | hoep.EXT_NO_INTRA_EMPHASIS
  hoep.HTML_SMARTYPANTS | hoep.HTML_ESCAPE


Record = declarative_base!
RecordMixIn = subclass object where
  __iter__ = self -> for f in @fields => yield $ getattr self f


User = subclass RecordMixIn Record where
  __tablename__ = 'users'
  fields = 'id', 'email'
  id       = Column Integer primary_key: True
  email    = Column String
  password = Column String


Pad = subclass RecordMixIn Record where
  __tablename__ = 'pads'
  fields = 'id', 'name'
  id    = Column Integer primary_key: True
  _refs = Column Integer
  _user = Column Integer $ ForeignKey 'users.id'
  name  = Column String
  user  = relationship 'User' backref: (backref 'pads' order_by: id)


Note = subclass RecordMixIn Record where
  __tablename__ = 'notes'
  fields = 'id', 'name', 'text', 'html', 'time', 'pad'
  id    = Column Integer primary_key: True
  name  = Column String
  text  = Column String
  html  = Column String
  time  = Column Integer
  _pad  = Column Integer $ ForeignKey 'pads.id'
  _user = Column Integer $ ForeignKey 'users.id'
  pad   = relationship 'Pad'  backref: (backref 'notes' order_by: time)
  user  = relationship 'User' backref: (backref 'notes' order_by: time)


engine  = create_engine config.DATABASE
session = (sessionmaker bind: engine)!
Record.metadata.create_all engine


create_user = email password -> except
  err => check_user email None
  err is None     => raise $ KeyError email
  err :: KeyError =>
    # FIXME should probably hash it.
    user = User email: email password: password
    session.add user
    session.commit!
    user


check_user = email password ->
  user = session.query User |>.filter_by email: email |>.first!
  user is None              => raise $ KeyError email
  user.password != password => password != None => raise $ ValueError
  user


update_user = user password ->
  user.password = password
  session.commit!
  user


set_user_password = email password ->
  user = check_user email None
  user.password = password
  session.commit!


get_pads  = user     -> user.pads
get_notes = user pad -> if
  pad is None => None, user.notes
  otherwise   =>
    pad = session.query Pad |>.filter_by _user: user.id id: pad |>.first!
    pad is None => raise KeyError
    pad, pad.notes


get_note = user id ->
  note = session.query Note |>.filter_by _user: user.id id: id |>.first!
  note is None => raise KeyError
  note


_get_pad_by_name = user name -> if
  not name  => None
  otherwise =>
    pad = session.query Pad |>.filter_by _user: user.id name: name |>.first!
    pad is None =>
      pad = Pad name: name user: user _refs: 0
      session.add pad
    pad


_rollback_on_error = f -> *: args -> except
  err     => f *: args
  finally => err => session.rollback!


pop_note = _rollback_on_error $ user id ->
  note = get_note user id
  note.pad =>
    note.pad._refs -= 1
    note.pad._refs <= 0 =>
      session.delete note.pad
  session.delete note
  session.commit!
  note


add_note = _rollback_on_error $ user name text pad ->
  md   = _md_renderer.render text
  ts   = int $ time.mktime time.localtime!
  pad  = _get_pad_by_name user pad
  note = Note name: name text: text html: md time: ts user: user pad: pad
  note.pad => note.pad._refs += 1
  session.add note
  session.commit!
  note


set_note = _rollback_on_error $ user id name text pad ->
  note = get_note user id
  note.html = _md_renderer.render text
  note.time = int $ time.mktime time.localtime!
  note.text = text
  note.name = name
  note.pad =>
    note.pad._refs -= 1
    note.pad._refs <= 0 => session.delete note.pad
  note.pad = _get_pad_by_name user pad
  note.pad => note.pad._refs += 1
  session.commit!
  note


set_pad = _rollback_on_error $ user id name ->
  pad = session.query Pad |>.filter_by _user: user.id id: id |>.first!
  pad is None => raise KeyError
  pad.name = name
  session.commit!
  pad
